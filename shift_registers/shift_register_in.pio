.program shift_register_in

.side_set 1 opt

.wrap_target
    push iffull block side 1
    in pins 1 side 0
.wrap

% c-sdk {

#include "hardware/clocks.h"
#include "shift_register_out.pio.h"

// SIPO
void init_in_shift_register(ShiftRegister *shiftRegister, uint offset, float clock) {
    clock *= 2;  // 2 instructions
    float clockDiv = (float) clock_get_hz(clk_sys) / clock;
    pio_sm_config c = shift_register_in_program_get_default_config(offset);

    pio_gpio_init(shiftRegister->pio, shiftRegister->dataPin);
    pio_gpio_init(shiftRegister->pio, shiftRegister->clockPin);

    sm_config_set_in_pins(&c, shiftRegister->dataPin);
    pio_sm_set_consecutive_pindirs(shiftRegister->pio, shiftRegister->sm, shiftRegister->dataPin, 1, false);
    sm_config_set_sideset_pins(&c, shiftRegister->clockPin);
    pio_sm_set_consecutive_pindirs(shiftRegister->pio, shiftRegister->sm, shiftRegister->clockPin, 1, true);

    sm_config_set_in_shift(&c, true, true, 8);

    sm_config_set_clkdiv(&c, clockDiv);
    pio_sm_init(shiftRegister->pio, shiftRegister->sm, offset, &c);
    pio_sm_set_enabled(shiftRegister->pio, shiftRegister->sm, true);
}

void read_from_shift_register(ShiftRegister *shiftRegister, uint8_t dataArray[]) {
    for (uint8_t i = 0; i < shiftRegister->registerCount; i++) {
        dataArray[i] = pio_sm_get_blocking(shiftRegister->pio, shiftRegister->sm) >> 24;
    }
}
%}
