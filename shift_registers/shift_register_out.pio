.program shift_register_out

.side_set 1 opt

.wrap_target
    pull ifempty block side 1
    out pins, 1 side 0
.wrap

% c-sdk {

typedef struct ShiftRegister {
    PIO pio;
    uint sm;
    uint8_t registerCount;
    uint8_t dataPin;
    uint8_t clockPin;
} ShiftRegister;

#include "hardware/clocks.h"

// SIPO
void init_out_shift_register(ShiftRegister *shiftRegister, uint offset, float clock) {
    clock *= 2;  // 2 instructions
    float clockDiv = (float) clock_get_hz(clk_sys) / clock;
    pio_sm_config c = shift_register_out_program_get_default_config(offset);

    pio_gpio_init(shiftRegister->pio, shiftRegister->dataPin);
    pio_gpio_init(shiftRegister->pio, shiftRegister->clockPin);

    sm_config_set_out_pins(&c, shiftRegister->dataPin, 1);
    pio_sm_set_consecutive_pindirs(shiftRegister->pio, shiftRegister->sm, shiftRegister->dataPin, 1, true);
    sm_config_set_sideset_pins(&c, shiftRegister->clockPin);
    pio_sm_set_consecutive_pindirs(shiftRegister->pio, shiftRegister->sm, shiftRegister->clockPin, 1, true);

    sm_config_set_out_shift(&c, true, true, 8);

    sm_config_set_clkdiv(&c, clockDiv);
    pio_sm_init(shiftRegister->pio, shiftRegister->sm, offset, &c);
    pio_sm_set_enabled(shiftRegister->pio, shiftRegister->sm, true);
}

void write_to_shift_register(ShiftRegister *shiftRegister, uint8_t *dataArray) {
    for (uint8_t i = 0; i < shiftRegister->registerCount; i++) {
        pio_sm_put_blocking(shiftRegister->pio, shiftRegister->sm, dataArray[i]);
    }
}
%}
